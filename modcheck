-- json.lua (dari rxi/json.lua) -- BEGIN
local json = { _version = "0.1.2" }

local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { ["\\/"] = "/", ["\\\\"] = "\\", ["\\\""] = "\"", ["\\b"] = "\b", ["\\f"] = "\f", ["\\n"] = "\n", ["\\r"] = "\r", ["\\t"] = "\t" }

local function escape_char(c)
  return escape_char_map[c] or c
end

local function encode_nil(val)
  return "null"
end

local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"
  else
    -- Treat as object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("JSON object keys must be strings")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end

local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end

local function encode_number(val)
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return tostring(val)
end

local type_func_map = {
  ["nil"] = encode_nil,
  ["table"] = encode_table,
  ["string"] = encode_string,
  ["number"] = encode_number,
  ["boolean"] = tostring,
}

encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end

function json.encode(val)
  return (encode(val))
end

local function decode_error(str, idx, msg)
  error(string.format("Error while decoding JSON at position %d: %s", idx, msg))
end

local function codepoint_to_utf8(n)
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n / 64) % 64 + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n / 4096) % 64 + 128, f(n / 64) % 64 + 128, n % 64 + 128)
  else
    error(string.format("invalid unicode codepoint '%x'", n))
  end
end

local function parse_unicode_escape(s)
  local n1 = tonumber(s:sub(1, 4), 16)
  local n2 = tonumber(s:sub(7, 10), 16)
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000), 10
  else
    return codepoint_to_utf8(n1), 6
  end
end

local function next_char(str, idx, expected)
  local c = str:sub(idx, idx)
  if c == expected then
    return idx + 1
  end
  decode_error(str, idx, "Expected '" .. expected .. "' but found '" .. c .. "'")
end

local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local len = #str
  while j <= len do
    local c = str:sub(j, j)
    if c == '"' then
      return res, j + 1
    elseif c == "\\" then
      local next_c = str:sub(j + 1, j + 1)
      if next_c == "u" then
        local hex = str:sub(j + 2, j + 5)
        if not hex:match("%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        local char, consumed = parse_unicode_escape(str:sub(j + 2))
        res = res .. char
        j = j + consumed
      else
        local map = {
          ["\""] = "\"",
          ["\\"] = "\\",
          ["/"] = "/",
          ["b"] = "\b",
          ["f"] = "\f",
          ["n"] = "\n",
          ["r"] = "\r",
          ["t"] = "\t",
        }
        if not map[next_c] then
          decode_error(str, j, "invalid escape char '" .. next_c .. "' in string")
        end
        res = res .. map[next_c]
        j = j + 2
      end
    else
      res = res .. c
      j = j + 1
    end
  end
  decode_error(str, i, "unterminated string")
end

local function parse_number(str, i)
  local num_str = ""
  local len = #str
  local j = i
  while j <= len do
    local c = str:sub(j, j)
    if c:match("[%d+%-.eE]") then
      num_str = num_str .. c
      j = j + 1
    else
      break
    end
  end
  local num = tonumber(num_str)
  if not num then
    decode_error(str, i, "invalid number")
  end
  return num, j
end

local function skip_whitespace(str, i)
  local len = #str
  local j = i
  while j <= len do
    local c = str:sub(j, j)
    if c ~= " " and c ~= "\t" and c ~= "\n" and c ~= "\r" then
      break
    end
    j = j + 1
  end
  return j
end

local function parse_value(str, i)
  i = skip_whitespace(str, i)
  local c = str:sub(i, i)
  if c == "{" then
    return parse_object(str, i)
  elseif c == "[" then
    return parse_array(str, i)
  elseif c == '"' then
    return parse_string(str, i)
  elseif c == "t" and str:sub(i, i + 3) == "true" then
    return true, i + 4
  elseif c == "f" and str:sub(i, i + 4) == "false" then
    return false, i + 5
  elseif c == "n" and str:sub(i, i + 3) == "null" then
    return nil, i + 4
  elseif c:match("[%d%-]") then
    return parse_number(str, i)
  else
    decode_error(str, i, "unexpected character '" .. c .. "'")
  end
end

function parse_array(str, i)
  local res = {}
  i = i + 1
  i = skip_whitespace(str, i)
  if str:sub(i, i) == "]" then
    return res, i + 1
  end
  while true do
    local val
    val, i = parse_value(str, i)
    table.insert(res, val)
    i = skip_whitespace(str, i)
    local c = str:sub(i, i)
    if c == "]" then
      return res, i + 1
    elseif c ~= "," then
      decode_error(str, i, "expected ',' or ']' in array")
    end
    i = i + 1
  end
end

function parse_object(str, i)
  local res = {}
  i = i + 1
  i = skip_whitespace(str, i)
  if str:sub(i, i) == "}" then
    return res, i + 1
  end
  while true do
    local key
    key, i = parse_string(str, i)
    i = skip_whitespace(str, i)
    i = next_char(str, i, ":")
    local val
    val, i = parse_value(str, i)
    res[key] = val
    i = skip_whitespace(str, i)
    local c = str:sub(i, i)
    if c == "}" then
      return res, i + 1
    elseif c ~= "," then
      decode_error(str, i, "expected ',' or '}' in object")
    end
    i = i + 1
  end
end

function json.decode(str)
  if type(str) ~= "string" then
    error("expected string for json.decode")
  end
  local res, idx = parse_value(str, 1)
  idx = skip_whitespace(str, idx)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end

function requestMods()
    local headers = {}
    local body = ""
    local timeout = 5000

    local res = makeRequest("https://api.noire.my.id/api/mods", "GET", headers, body, timeout)

    if not res or not res.content then
        logToConsole("[X] Failed to retrieve data from API.")
        return nil
    end

    return res.content
end

function checkMods(jsonString)
    local status, data = pcall(json.decode, jsonString)
    if not status then
        logToConsole("[X] Failed decode JSON: " .. tostring(data))
        return
    end

    if not data.mods or type(data.mods) ~= "table" then
        logToConsole("[X] Data 'mods' not found in JSON.")
        return
    end

    local onlineMods = {}
    local kailyxLog = nil

    for _, mod in ipairs(data.mods) do
        if type(mod.status) == "string" then
            local stat = mod.status:lower()
            if stat == "online" or stat == "undercover" then
                if mod.name:lower() == "kailyx" then
                    if stat == "undercover" then
                        kailyxLog = "`#kailyx (evil wife is undercover)"
                    elseif stat == "online" then
                        kailyxLog = "`#kailyx (evil wife is online)"
                    end
                else
                    table.insert(onlineMods, mod.name .. " (" .. mod.status .. ")")
                end
            end
        end
    end

    if kailyxLog then
        logToConsole("[!] MODs detected: " .. kailyxLog)
    end

    if #onlineMods > 0 then
        logToConsole("[!] MODs detected: `#" .. table.concat(onlineMods, ", "))
    elseif not kailyxLog then
        logToConsole("`2[âœ“] No MODs online. Safe farming~")
    end
end

function checkModsAPI()
    local content = requestMods()
    if content then
        checkMods(content)
    end
end

function hookMods(_, pkt)
    if pkt:find("action|input\n|text|/mods%.") then
        checkModsAPI()
        return true
    end
end

AddHook("OnTextPacket", "CheckModsHook", hookMods)
